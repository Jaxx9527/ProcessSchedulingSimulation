# ProcessSchedulingSimulation
模擬作業系統行程調度  

## 題目要求
### 1.	实验目的
 本实验要求编写一个简单的进程调度程序以加深理解有关进程控制块、进程队列的概念，并体会进程调度算法的具体实施办法。  

### 2.	实验内容
选择任意一种算法设计一个有 N（不少于 4）个进程共行的进程调度程序。  
原理分析：  
1. 假设系统有 5 个进程，每个进程用一个进程控制块来代表。  
2. 为每个进程任意确定一个要求运行时间和到达时间。  
3. 按照进程到达的先后顺序拍成一个循环队列，再设一个队首指针指向第一个到达进程的首地址  
4. 执行处理机调度时，开始选择队首的第一个程序运行。另外，再设一个当前运行进程的指针，指 向当前正在运行的进程。  
5. 进程运行一次后，估计运行时间减一，输出当前运行进程的名字。  
6. 进程运行一次后，调整当前运行指针指向该进程的连接指针所指进程，已指示应运行进程。同时 还应判断给该进程的剩余时间是否为 0，若不为 0 则等待下一轮的运行，否则将该进程的状态置为完成态，并推出循环队列。
7. 若就绪队列不空，则重复（5）和（6），直至所有进程运行完为止。  
8. 在所设计的程序中，应包含显示或打印语句。显示或打印每次选中的进程的名称及运行一次后队列的变化情况。  
## 實驗環境
 编译标准：C++ 17  

## 實驗過程
 在命令行中，输入以下参数，得到模拟调度结果。   
```
请输入进程数量 (N>=4): 4
进程 1  名称: P1
进程 1  到达时间: 0
进程 1  要求运行时间: 20
进程 2  名称: P2
进程 2  到达时间: 5
进程 2  要求运行时间: 5
进程 3  名称: P3
进程 3  到达时间: 10
进程 3  要求运行时间: 16
进程 4  名称: P4
进程 4  到达时间: 20
进程 4  要求运行时间: 20
```
<table >
  <tr>
    <td align="center">Round Robin 算法</td>
    <td align="center">抢占式 SJF 算法</td>
  </tr>
<tr>
  <td><img width="100%" alt="image" src="https://raw.githubusercontent.com/Jaxx9527/ProcessSchedulingSimulation/refs/heads/main/9zGnuPNRBw.png" />
</td>
  <td><img width="100%" alt="image" src="https://raw.githubusercontent.com/Jaxx9527/ProcessSchedulingSimulation/refs/heads/main/AGvbBXCo8f.png" />
</td>
</tr>
</table>

## 實驗結果
抢占式 SJF 算法对比 Round  Robin 算法，所有进程总开销时间一致，但进程平均完成时间更低。  
在操作系统实作中， 实际上无法实现 SJF 算法，因为无法提前知道程式需要运行时间是多少。
通过本次实验，我获得以下几点收获：  
1. 加深对操作系统核心概念的理解。  
2. 掌握调度算法：抢占式 SJF 算法和 Round Robin 算法的实现细节。  
3. 锻炼了 C 语言指针与动态数据结构编程能力。  
